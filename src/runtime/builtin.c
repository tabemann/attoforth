/* Copyright (c) 2018, Travis Bemann
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE. */

#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stddef.h>
#include "af/common.h"
#include "af/types.h"
#include "af/inner.h"

void af_compile_builtin(af_global_t* global, af_task_t* task) {
  af_input_t* input;
  uint8_t* code =
    "FORTH-WORDLIST IO-WORDLIST TASK-WORDLIST 3 SET-ORDER "
    "FORTH-WORDLIST SET-CURRENT "
    ": TRUE -1 ; "
    ": FALSE 0 ; "
    ": NEGATE -1 * ; "
    ": DNEGATE -1. D* ; "
    ": FNEGATE -1e F* ; "
    ": 0< 0 < ; "
    ": 0= 0 = ; "
    ": 0> 0 > ; "
    ": 0<> 0 <> ; "
    ": 0<= 0 <= ; "
    ": 0>= 0 >= ; "
    ": D0< 0. D< ; "
    ": D0= 0. D= ; "
    ": D0> 0. D> ; "
    ": D0<> 0. D<> ; "
    ": D0<= 0. D<= ; "
    ": D0>= 0. D>= ; "
    ": F0< 0e F< ; "
    ": F0= 0e F= ; "
    ": F0> 0e F> ; "
    ": F0<> 0e F<> ; "
    ": F0<= 0e F<= ; "
    ": F0>= 0e F>= ; "
    ": 1+ 1 + ; "
    ": 1- 1 - ; "
    ": 2+ 2 + ; "
    ": 2- 2 - ; "
    ": 2* 2 * ; "
    ": 2/ 2 * ; "
    ": DEPTH SP0 SP@ - CELL-SIZE / 1- ; "
    ": FDEPTH FP0 FP@ - FLOAT-SIZE / ; "
    ": , HERE ! CELL-SIZE ALLOT ; "
    ": C, HERE C! 1 ALLOT ; "
    ": F, HERE F! FLOAT-SIZE ALLOT ; "
    ": SF, HERE SF! SFLOAT-SIZE ALLOT ; "
    ": DF, HERE DF! DFLOAT-SIZE ALLOT ; "
    ": COMPILE, , ; "
    ": [COMPILE] ' COMPILE, ; IMMEDIATE "
    ": COMPILE ' ['] (LITERAL) COMPILE, , ['] COMPILE, COMPILE, ; IMMEDIATE "
    ": LITERAL COMPILE (LITERAL) , ; IMMEDIATE "
    ": FLITERAL COMPILE (FLITERAL) F, ; IMMEDIATE "
    ": 2LITERAL SWAP COMPILE (LITERAL) , COMPILE (LITERAL) , ; IMMEDIATE "
    ": BINARY 2 BASE ! ; "
    ": OCT 8 BASE ! ; "
    ": DEC 10 BASE ! ; "
    ": DECIMAL 10 BASE ! ; "
    ": HEX 16 BASE ! ; "
    ": BASE-EXECUTE BASE @ >R BASE ! EXECUTE R> BASE ! ; "
    ": CELL+ CELL-SIZE + ; "
    ": CELLS CELL-SIZE * ; "
    ": FLOAT+ FLOAT-SIZE + ; "
    ": FLOATS FLOAT-SIZE * ; "
    ": SFLOAT+ SFLOAT-SIZE + ; "
    ": SFLOATS SFLOAT-SIZE * ; "
    ": DFLOAT+ DFLOAT-SIZE + ; "
    ": DFLOATS DFLOAT-SIZE * ; "
    ": CHARS ; "
    ": CHAR+ 1+ ; "
    ": HEADER-SIZE 5 CELLS ; "
    ": NIP SWAP DROP ; "
    ": TUCK SWAP OVER ; "
    ": 2DROP DROP DROP ; "
    ": 2DUP OVER OVER ; "
    ": 2SWAP 3 ROLL 3 ROLL ; "
    ": 2OVER 3 PICK 3 PICK ; "
    ": 2ROT 5 ROLL 5 ROLL ; "
    ": FNIP FSWAP FDROP ; "
    ": FTUCK FSWAP FOVER ; "
    ": F2DROP FDROP FDROP ; "
    ": F2DUP FOVER FOVER ; "
    ": F2SWAP 3 FROLL 3 FROLL ; "
    ": F2OVER 3 FPICK 3 FPICK ; "
    ": F2ROT 5 FROLL 5 FROLL ; "
    ": 2! TUCK ! CELL+ ! ; "
    ": 2@ DUP @ SWAP CELL+ @ SWAP ; "
    ": 2, HERE 2! [ 2 CELLS ] LITERAL ALLOT ; "
    ": F2! DUP F! FLOAT+ F! ; " 
    ": F2@ DUP F@ FLOAT+ F@ FSWAP ; "
    ": F2, HERE F2! [ 2 FLOATS ] LITERAL ALLOT ; "
    ": 2>R R> ROT ROT SWAP >R >R >R ; "
    ": 2R> R> R> R> SWAP ROT >R ; "
    ": 2R@ R> R> R> 2DUP SWAP ROT >R ROT >R ROT >R ; "
    ": VARIABLE CREATE 0 , ; "
    ": CONSTANT CREATE , DOES> @ ; "
    ": 2VARIABLE CREATE 0. 2, ; "
    ": 2CONSTANT CREATE 2, DOES> 2@ ; "
    ": FVARIABLE CREATE 0e F, ; "
    ": FCONSTANT CREATE F, DOES> F@ ; "
    ": OFFSET CREATE , DOES> @ + ; "
    ": IF COMPILE ?BRANCH HERE 0 , ; IMMEDIATE "
    ": ELSE COMPILE BRANCH HERE 0 , HERE ROT ! ; IMMEDIATE "
    ": THEN HERE SWAP ! ; IMMEDIATE "
    ": POSTPONE ' DUP IS-IMMEDIATE IF "
    "    COMPILE, "
    "  ELSE "
    "    COMPILE (LITERAL) , COMPILE COMPILE, "
    "  THEN ; IMMEDIATE "
    ": & POSTPONE POSTPONE ; IMMEDIATE "
    ": ENDIF & THEN ; IMMEDIATE "
    ": RECURSE LATESTXT COMPILE, ; IMMEDIATE "
    ": DEFER-ABORT CREATE 0 , DOES> @ EXECUTE ; "
    "DEFER-ABORT ABORT "
    ": DEFER CREATE ['] ABORT , DOES> @ EXECUTE ; "
    ": DEFER! >BODY ! ; "
    ": DEFER@ >BODY @ ; "
    ": ACTION-OF STATE @ IF & ['] & DEFER@ ELSE ' DEFER@ THEN ; "
    "  IMMEDIATE "
    ": IS STATE @ IF & ['] & DEFER! ELSE ' DEFER! THEN ; "
    "  IMMEDIATE "
    ": ALLOCATE! ALLOCATE IF DROP ABORT THEN ; "
    ": FREE! FREE IF ABORT THEN ; "
    ": DROPS CELLS SP@ + CELL+ SP! ; "
    ": NIPS SWAP >R 1- DROPS R> ; "
    ": FDROPS FLOATS FP@ + FP! ; "
    ": FNIPS FP@ SWAP 1+ FDROPS F@ ; "
    ": MOVE-FROM-STACK DUP >R CELLS SP@ 2 CELLS + ROT ROT MOVE R> DROPS ; "
    ": MOVE-TO-STACK SWAP >R CELLS DUP >R NEGATE SP@ + CELL+ DUP >R SP! "
    "  R> R> R> ROT ROT MOVE ; "
    ": MOVE-FROM-FLOAT-STACK DUP FLOATS FP@ 3 ROLL ROT MOVE FDROPS ; "
    ": MOVE-TO-FLOAT-STACK FLOATS DUP NEGATE FP@ + DUP FP! SWAP MOVE ; " 
    ": ?DUP DUP IF DUP THEN ; "
    ": ALIGN HERE CELL-SIZE MOD DUP 0<> IF "
    "    CELL-SIZE SWAP - ALLOT "
    "  ELSE "
    "    DROP "
    "  THEN ; "
    ": ALIGNED DUP CELL-SIZE MOD DUP 0<> IF "
    "    CELL-SIZE SWAP - + "
    "  ELSE "
    "    DROP "
    "  THEN ; "
    ": FALIGN HERE FLOAT-SIZE MOD DUP 0<> IF "
    "    FLOAT-SIZE SWAP - ALLOT "
    "  ELSE "
    "    DROP "
    "  THEN ; "
    ": FALIGNED DUP FLOAT-SIZE MOD DUP 0<> iF "
    "    FLOAT-SIZE SWAP - + "
    "  ELSE "
    "    DROP "
    "  THEN ; "
    ": SFALIGN HERE SFLOAT-SIZE MOD DUP 0<> IF "
    "    SFLOAT-SIZE SWAP - ALLOT "
    "  ELSE "
    "    DROP "
    "  THEN ; "
    ": SFALIGNED DUP SFLOAT-SIZE MOD DUP 0<> iF "
    "    SFLOAT-SIZE SWAP - + "
    "  ELSE "
    "    DROP "
    "  THEN ; "
    ": DFALIGN HERE DFLOAT-SIZE MOD DUP 0<> IF "
    "    DFLOAT-SIZE SWAP - ALLOT "
    "  ELSE "
    "    DROP "
    "  THEN ; "
    ": DFALIGNED DUP DFLOAT-SIZE MOD DUP 0<> iF "
    "    DFLOAT-SIZE SWAP - + "
    "  ELSE "
    "    DROP "
    "  THEN ; "
    ": BEGIN-STRUCTURE CREATE HERE 0 0 , DOES> @ ; "
    ": END-STRUCTURE SWAP ! ; "
    ": +FIELD CREATE OVER , + DOES> @ + ; "
    ": CFIELD: CREATE DUP , [ 1 CHARS ] LITERAL + DOES> @ + ; "
    ": FIELD: CREATE ALIGNED DUP , [ 1 CELLS ] LITERAL + DOES> @ + ; "
    ": FFIELD: CREATE FALIGNED DUP , [ 1 FLOATS ] LITERAL + DOES> @ + ; "
    ": SFFIELD: CREATE SFALIGNED DUP , [ 1 SFLOATS ] LITERAL + DOES> @ + ; "
    ": DFFIELD: CREATE DFALIGNED DUP , [ 1 DFLOATS ] LITERAL + DOES> @ + ; "
    ": S>D DUP 0>= IF 0 ELSE -1 THEN ; "
    ": D>S DUP 0> IF 2DROP -1 1 RSHIFT ELSE 0< IF DROP -1 THEN THEN ; "
    "DEFER INTERPRET "
    ": BEGIN HERE ; IMMEDIATE "
    ": AGAIN & BRANCH , ; IMMEDIATE "
    ": UNTIL & ?BRANCH , ; IMMEDIATE "
    ": WHILE & ?BRANCH HERE 0 , ; IMMEDIATE "
    ": REPEAT & BRANCH SWAP , HERE SWAP ! ; IMMEDIATE "
    ": CASE 0 ; IMMEDIATE "
    ": OF & 2DUP & = & IF & 2DROP ; IMMEDIATE "
    ": ENDOF SWAP ?DUP IF HERE SWAP ! THEN "
    "  & BRANCH HERE 0 , SWAP & ELSE & DROP & THEN ; IMMEDIATE "
    ": ENDCASE & DROP ?DUP IF HERE SWAP ! THEN ; IMMEDIATE "
    ": ?EXECUTE1 DUP IF EXECUTE ELSE 2DROP THEN ; "
    "IO-WORDLIST SET-CURRENT "
    "0 HERE ! HERE 1 CELLS TASK-LOCAL CONSTANT OUTPUT "
    "0 HERE ! HERE 1 CELLS TASK-LOCAL CONSTANT ERROR "
    "BEGIN-STRUCTURE OUTPUT-SIZE "
    "  FIELD: OUTPUT-NEXT-OUTPUT "
    "  FIELD: OUTPUT-WRITE "
    "  FIELD: OUTPUT-CLEANUP "
    "  FIELD: OUTPUT-ARG "
    "END-STRUCTURE "
    ": >OUTPUT OUTPUT SWAP T! ; "
    ": >ERROR ERROR SWAP T! ; "
    ": OUTPUT> OUTPUT SWAP T@ ; "
    ": ERROR> ERROR SWAP T@ ; "
    ": LAST-OUTPUT "
    "  BEGIN "
    "    DUP 0<> IF DUP OUTPUT-NEXT-OUTPUT @ 0<> ELSE FALSE THEN "
    "  WHILE "
    "    OUTPUT-NEXT-OUTPUT @ "
    "  REPEAT ; "
    ": CONSOLE-OUTPUT> OUTPUT SWAP T@ LAST-OUTPUT ; "
    ": CONSOLE-ERROR> ERROR SWAP T@ LAST-OUTPUT ; "
    ": >CONSOLE-OUTPUT DUP OUTPUT SWAP T@ LAST-OUTPUT DUP 0<> IF "
    "    NIP OUTPUT-NEXT-OUTPUT ! "
    "  ELSE "
    "    DROP OUTPUT SWAP T! "
    "  THEN ; "
    ": >CONSOLE-ERROR DUP ERROR SWAP T@ LAST-OUTPUT DUP 0<> IF "
    "    NIP OUTPUT-NEXT-OUTPUT ! "
    "  ELSE "
    "    DROP ERROR SWAP T! "
    "  THEN ; "
    "FORTH-WORDLIST SET-CURRENT "
    ": TYPE THIS-TASK OUTPUT> DUP IF "
    "    DUP OUTPUT-WRITE @ DUP IF EXECUTE ELSE 2DROP 2DROP THEN "
    "  ELSE "
    "    DROP "
    "  THEN ; "
    ": EMIT HERE $100 + C! HERE $100 + 1 TYPE ; "
    "$20 CONSTANT BL "
    "$0A CONSTANT NEWLINE "
    "$09 CONSTANT TAB "
    ": CR NEWLINE EMIT ; "
    ": SPACE BL EMIT ; "
    ": ERROR-TYPE THIS-TASK ERROR> DUP IF "
    "    DUP OUTPUT-WRITE @ ?EXECUTE1 "
    "  ELSE "
    "    DROP "
    "  THEN ; "
    ": SKIP-WHITESPACE BEGIN SOURCE >IN 2DUP @ > IF "
    "    DUP @ 3 PICK + C@ DUP BL = OVER TAB = OR SWAP NEWLINE = OR IF "
    "      DUP @ 1+ SWAP ! 2DROP FALSE "
    "    ELSE 2DROP DROP TRUE THEN "
    "  ELSE 2DROP DROP TRUE THEN UNTIL ; "
    ": SKIP-UNTIL-WHITESPACE BEGIN SOURCE >IN 2DUP @ > IF "
    "    DUP @ 3 PICK + C@ DUP BL <> OVER TAB <> AND SWAP NEWLINE <> AND IF "
    "      DUP @ 1+ SWAP ! 2DROP FALSE "
    "    ELSE 2DROP DROP TRUE THEN "
    "  ELSE 2DROP DROP TRUE THEN UNTIL ; "
    ": PARSE-NAME "
    "  SKIP-WHITESPACE SOURCE NIP >IN @ > IF "
    "    SOURCE DROP >IN @ SKIP-UNTIL-WHITESPACE TUCK + >IN @ ROT - "
    "    DUP 0= IF 2DROP 0 0 THEN "
    "  ELSE "
    "    0 0 "
    "  THEN ; "
    ": CHAR PARSE-NAME 1 >= IF C@ ELSE DROP 0 THEN ; "
    ": [CHAR] PARSE-NAME 1 >= IF C@ ELSE DROP 0 THEN & (LITERAL) , ; "
    "  IMMEDIATE "
    ": SKIP-CHARS-UNTIL SOURCE >IN BEGIN 2DUP @ > IF "
    "    DUP @ 3 PICK + C@ 4 PICK = OVER DUP @ 1+ SWAP ! "
    "  ELSE TRUE THEN UNTIL 2DROP 2DROP ; "
    ": COUNT-CHARS-UNTIL SOURCE >IN 0 BEGIN 2 PICK 2 PICK @ > IF "
    "    OVER @ 4 PICK + C@ 5 PICK = DUP IF ELSE SWAP 1+ SWAP THEN "
    "    2 PICK DUP @ 1+ SWAP ! "
    "  ELSE TRUE THEN UNTIL ROT ROT 2DROP ROT ROT 2DROP ; "
    ": ( [CHAR] ) SKIP-CHARS-UNTIL ; IMMEDIATE "
    ": \\ NEWLINE SKIP-CHARS-UNTIL ; IMMEDIATE "
    ": SIMPLE-EMIT ( c -- ) "
    "  HERE $101 + TUCK ! 1 IO-STDOUT IO-WRITE-ASYNC IO-ACTION-DESTROY ; "
    ": TIME+ ( s1 ns1 s2 ns2 -- s ns ) "
    "  DUP 3 PICK + 1000000000 > IF "
    "    2 ROLL + 1000000000 - ROT ROT + 1+ SWAP "
    "  ELSE "
    "    2 ROLL + ROT ROT + SWAP "
    "  THEN ; "
    ": FIX-TIME ( s ns -- s ns ) "
    "    DUP 1000000000 / ROT + SWAP 1000000000 MOD ; "
    "TASK-WORDLIST SET-CURRENT "
    ": SLEEP ( s ns -- ) IO-GET-MONOTONIC-TIME TIME+ IO-SLEEP ; "
    ": SIMPLE-LOCK ( addr -- ) "
    "  BEGIN 0 THIS-TASK 2 PICK CAS IF DROP TRUE ELSE YIELD FALSE THEN UNTIL ; "
    ": SIMPLE-UNLOCK ( addr -- ) THIS-TASK 0 ROT CAS DROP ; "
    "BEGIN-STRUCTURE LOCK-SIZE "
    "  FIELD: LOCK-PRIMARY "
    "  FIELD: LOCK-SECONDARY "
    "  FIELD: LOCK-WAITING "
    "  FIELD: LOCK-WAITING-COUNT "
    "  FIELD: LOCK-WAITING-SIZE "
    "  FIELD: LOCK-UNLOCK-COUNT "
    "END-STRUCTURE "
    "8 CONSTANT DEFAULT-LOCK-WAITING-SIZE "
    ": NEW-LOCK ( -- lock ) "
    "  LOCK-SIZE ALLOCATE! 0 OVER LOCK-PRIMARY ! 0 OVER LOCK-SECONDARY ! "
    "  DEFAULT-LOCK-WAITING-SIZE CELLS ALLOCATE! OVER LOCK-WAITING ! "
    "  0 OVER LOCK-WAITING-COUNT ! "
    "  0 OVER LOCK-UNLOCK-COUNT ! "
    "  DEFAULT-LOCK-WAITING-SIZE OVER LOCK-WAITING-SIZE ! ; "
    ": DESTROY-LOCK ( lock -- ) DUP LOCK-WAITING @ FREE! FREE! ;  "
    ": LOCK ( lock -- ) "
    "  DUP LOCK-SECONDARY SIMPLE-LOCK "
    "  BEGIN "
    "    0 THIS-TASK 2 PICK LOCK-PRIMARY CAS IF "
    "      LOCK-SECONDARY SIMPLE-UNLOCK TRUE "
    "    ELSE THIS-TASK OVER LOCK-PRIMARY @ = IF "
    "      LOCK-SECONDARY SIMPLE-UNLOCK TRUE "
    "    ELSE "
    "      DUP LOCK-WAITING-COUNT @ OVER LOCK-WAITING-SIZE @ = IF "
    "        DUP LOCK-WAITING-SIZE @ DUP 2 * DUP 3 PICK LOCK-WAITING-SIZE ! "
    "        CELLS ALLOCATE! DUP 3 PICK LOCK-WAITING @ "
    "        SWAP DUP ROT 4 ROLL CELLS MOVE FREE! OVER LOCK-WAITING ! "
    "      THEN "
    "      THIS-TASK OVER LOCK-WAITING-COUNT @ CELLS 2 PICK "
    "      LOCK-WAITING @ + ! DUP LOCK-WAITING-COUNT @ 1+ "
    "      OVER LOCK-WAITING-COUNT ! "
    "      DUP LOCK-SECONDARY SIMPLE-UNLOCK THIS-TASK WAIT "
    "      DUP LOCK-SECONDARY SIMPLE-LOCK FALSE "
    "    THEN THEN "
    "  UNTIL ; "
    ": HAS-LOCK ( task lock -- boolean ) LOCK-PRIMARY @ = ; "
    ": UNLOCK ( lock -- ) "
    "  DUP LOCK-SECONDARY SIMPLE-LOCK "
    "  THIS-TASK OVER HAS-LOCK IF "
    "    DUP LOCK-WAITING-COUNT @ 0= IF "
    "      0 OVER LOCK-PRIMARY ! "
    "      ( 1 OVER LOCK-UNLOCK-COUNT +! ) "
    "      LOCK-SECONDARY SIMPLE-UNLOCK "
    "    ELSE "
    "      DUP LOCK-WAITING @ DUP @ SWAP DUP CELL+ SWAP 3 PICK "
    "      LOCK-WAITING-COUNT @ 1- DUP 5 PICK LOCK-WAITING-COUNT ! CELLS MOVE "
    "      DUP 2 PICK LOCK-PRIMARY ! "
    "      ( 1 2 PICK LOCK-UNLOCK-COUNT +! ) "
    "      WAKE LOCK-SECONDARY SIMPLE-UNLOCK YIELD "
    "    THEN "
    "  ELSE "
    "    LOCK-SECONDARY SIMPLE-UNLOCK TRUE "
    "    ABORT "
    "  THEN ; "
    ": UNLOCK-NO-RELOCK ( lock -- ) "
    "  DUP LOCK-SECONDARY SIMPLE-LOCK "
    "  THIS-TASK OVER HAS-LOCK IF "
    "    DUP LOCK-WAITING-COUNT @ 0= IF "
    "      0 OVER LOCK-PRIMARY ! "
    "      ( 1 OVER LOCK-UNLOCK-COUNT +! ) "
    "      LOCK-SECONDARY SIMPLE-UNLOCK "
    "    ELSE "
    "      DUP LOCK-WAITING @ DUP @ SWAP DUP CELL+ SWAP 3 PICK "
    "      LOCK-WAITING-COUNT @ 1- DUP 5 PICK LOCK-WAITING-COUNT ! CELLS MOVE "
    "      ( 1 2 PICK LOCK-UNLOCK-COUNT +! ) "
    "      WAKE LOCK-SECONDARY SIMPLE-UNLOCK "
    "    THEN "
    "  ELSE "
    "    LOCK-SECONDARY SIMPLE-UNLOCK TRUE "
    "    ABORT "
    "  THEN ; "
    ": UNLOCK-COUNT-RELOCK ( count lock -- ) "
    "  DUP LOCK-SECONDARY SIMPLE-LOCK "
    "  THIS-TASK OVER HAS-LOCK IF "
    "    DUP LOCK-WAITING-COUNT @ 0= IF "
    "      0 OVER LOCK-PRIMARY ! "
    "      ( 1 OVER LOCK-UNLOCK-COUNT +! ) "
    "      LOCK-SECONDARY SIMPLE-UNLOCK DROP "
    "    ELSE "
    "      DUP LOCK-WAITING @ DUP @ SWAP DUP CELL+ SWAP 3 PICK "
    "      LOCK-WAITING-COUNT @ 1- DUP 5 PICK LOCK-WAITING-COUNT ! CELLS MOVE "
    "      OVER LOCK-UNLOCK-COUNT @ 3 ROLL >= IF "
    "        DUP 2 PICK LOCK-PRIMARY ! "
    "        0 2 PICK LOCK-UNLOCK-COUNT ! "
    "        WAKE LOCK-SECONDARY SIMPLE-UNLOCK YIELD "
    "      ELSE "
    "        1 2 PICK LOCK-UNLOCK-COUNT +! "
    "        WAKE LOCK-SECONDARY SIMPLE-UNLOCK "
    "      THEN "
    "    THEN "
    "  ELSE "
    "    LOCK-SECONDARY SIMPLE-UNLOCK DROP "
    "    ABORT "
    "  THEN ; "
    "IO-WORDLIST SET-CURRENT "
    "NEW-LOCK CONSTANT TERMINAL-LOCK "
    ": LOCK-TERMINAL ( -- ) TERMINAL-LOCK LOCK ; "
    ": UNLOCK-TERMINAL ( -- ) TERMINAL-LOCK UNLOCK ; "
    ": FD>OUTPUT-CLEANUP FREE! ; "
    ": FD>OUTPUT-WRITE "
    "  DUP OUTPUT-ARG @ DUP IO-STDOUT = SWAP IO-STDERR = OR IF "
    "    THIS-TASK TERMINAL-LOCK HAS-LOCK 0= IF "
    "      LOCK-TERMINAL TRUE "
    "    ELSE "
    "      FALSE "
    "    THEN "
    "  ELSE "
    "    FALSE "
    "  THEN "
    "  3 ROLL 3 ROLL 3 ROLL OUTPUT-ARG @ IO-WRITE-ASYNC IO-ACTION-DESTROY "
    "  IF "
    "    UNLOCK-TERMINAL "
    "  THEN ; "
    ": FD>OUTPUT "
    "  OUTPUT-SIZE ALLOCATE! TUCK OUTPUT-ARG ! "
    "  0 OVER OUTPUT-NEXT-OUTPUT ! "
    "  ['] FD>OUTPUT-WRITE OVER OUTPUT-WRITE ! "
    "  ['] FD>OUTPUT-CLEANUP OVER OUTPUT-CLEANUP ! ; "
    "TASK-WORDLIST SET-CURRENT "
    ": OLD-SPAWN SPAWN ; "
    ": SPAWN OLD-SPAWN IO-STDOUT FD>OUTPUT OVER >CONSOLE-OUTPUT "
    "  IO-STDERR FD>OUTPUT OVER >CONSOLE-ERROR ; "
    "IO-STDOUT FD>OUTPUT THIS-TASK >CONSOLE-OUTPUT "
    "IO-STDERR FD>OUTPUT THIS-TASK >CONSOLE-ERROR "
    "FORTH-WORDLIST SET-CURRENT "
    "-1 CONSTANT EABORT "
    "-2 CONSTANT EABORT\" "
    "-3 CONSTANT ESTACK-OVERFLOW "
    "-4 CONSTANT ESTACK-UNDERFLOW "
    "-5 CONSTANT ERETURN-STACK-OVERFLOW "
    "-6 CONSTANT ERETURN-STACK-UNDERFLOW "
    "-44 CONSTANT EFLOAT-STACK-OVERFLOW "
    "-45 CONSTANT EFLOAT-STACK-UNDERFLOW "
    "-56 CONSTANT EQUIT "
    "-256 CONSTANT ERETURN "
    "0 HERE ! HERE 1 CELLS TASK-LOCAL CONSTANT HANDLER "
    ": CATCH THIS-TASK INPUT> >R THIS-TASK OUTPUT> >R THIS-TASK ERROR> >R "
    "  SP@ >R HANDLER THIS-TASK T@ >R RP@ HANDLER THIS-TASK T! "
    "  EXECUTE R> HANDLER THIS-TASK T! R> DROP R> DROP R> DROP R> DROP 0 ; "
    ": IS-IN-INPUT-STACK BEGIN "
    "    DUP 0<> IF "
    "      DUP 2 PICK <> IF "
    "        INPUT-NEXT-INPUT @ FALSE "
    "      ELSE "
    "        2DROP TRUE TRUE "
    "      THEN "
    "    ELSE "
    "      2DROP FALSE TRUE "
    "    THEN "
    "  UNTIL ; "
    ": IS-IN-OUTPUT-STACK BEGIN "
    "    DUP 0<> IF "
    "      DUP 2 PICK <> IF "
    "        OUTPUT-NEXT-OUTPUT @ FALSE "
    "      ELSE "
    "        2DROP TRUE TRUE "
    "      THEN "
    "    ELSE "
    "      2DROP FALSE TRUE "
    "    THEN "
    "  UNTIL ; "
    ": RESOLVE-INPUT DUP THIS-TASK INPUT> IS-IN-INPUT-STACK IF "
    "    THIS-TASK INPUT> BEGIN 2DUP <> WHILE "
    "      DUP INPUT-NEXT-INPUT @ SWAP DUP INPUT-CLEANUP @ ?EXECUTE1 "
    "    REPEAT "
    "    DROP THIS-TASK >INPUT "
    "  ELSE "
    "    DROP "
    "  THEN ; "
    ": RESOLVE-OUTPUT DUP THIS-TASK OUTPUT> IS-IN-OUTPUT-STACK IF "
    "    THIS-TASK OUTPUT> BEGIN 2DUP <> WHILE "
    "      DUP OUTPUT-NEXT-OUTPUT @ SWAP DUP OUTPUT-CLEANUP @ ?EXECUTE1 "
    "    REPEAT "
    "    DROP THIS-TASK >OUTPUT "
    "  ELSE "
    "    DROP "
    "  THEN ; "
    ": RESOLVE-ERROR DUP THIS-TASK OUTPUT> IS-IN-OUTPUT-STACK IF "
    "    THIS-TASK ERROR> BEGIN 2DUP <> WHILE "
    "      DUP OUTPUT-NEXT-OUTPUT @ SWAP DUP OUTPUT-CLEANUP @ ?EXECUTE1 "
    "    REPEAT "
    "    DROP THIS-TASK >ERROR "
    "  ELSE "
    "    DROP "
    "  THEN ; "
    ": THROW "
    "  ?DUP IF "
    "    HANDLER THIS-TASK T@ RP! R> HANDLER THIS-TASK T! R> SWAP >R "
    "    SP! DROP R> R> RESOLVE-ERROR R> RESOLVE-OUTPUT R> RESOLVE-INPUT "
    "  THEN ; "
    ":NONAME EABORT THROW ; ' ABORT DEFER! "
    ": DO & (LITERAL) HERE DUP 0 , & >R & 2>R HERE ; IMMEDIATE "
    ": ?DO & (LITERAL) HERE 0 , & >R & 2DUP & 2>R & <> & ?BRANCH HERE 0 , HERE "
    "  ; IMMEDIATE "
    ": LOOP & 2R> & 1+ & 2DUP & 2>R & = & ?BRANCH , HERE SWAP ! HERE SWAP ! "
    "  & 2R> & 2DROP & R> & DROP ; IMMEDIATE "
    ": +LOOP & 2R> & ROT & DUP & 0>= & IF "
    "    & SWAP & DUP & (LITERAL) 3 , & PICK & < & ROT & ROT & + "
    "    & DUP & (LITERAL) 3 , & PICK & >= & ROT & AND & ROT & ROT & 2>R "
    "  & ELSE "
    "    & SWAP & DUP & (LITERAL) 3 , & PICK & >= & ROT & ROT & + "
    "    & DUP & (LITERAL) 3 , & PICK & < & ROT & AND & ROT & ROT & 2>R "
    "  & THEN "
    "  & ?BRANCH , HERE SWAP ! HERE SWAP ! & 2R> & 2DROP & R> & DROP ; "
    "  IMMEDIATE "
    ": LEAVE R> 2R> 2DROP >R ; "
    ": UNLOOP R> 2R> 2DROP R> DROP >R ; "
    ": I R> R@ SWAP >R ; "
    ": J 2R> 2R> R@ 4 ROLL 4 ROLL 4 ROLL 4 ROLL 2>R 2>R ; "
    ": COUNT ( addr -- addr1 u ) DUP C@ SWAP 1+ SWAP ; "
    ": FILL ( addr count char -- ) "
    "  SWAP 0 ?DO "
    "    DUP 2 PICK C! SWAP CHAR+ SWAP  "
    "  LOOP 2DROP ; "
    ": DISCARD ( x1 ... xn u -- ) 0 ?DO DROP LOOP ; "
    ": DEFINITIONS ( -- ) GET-ORDER SWAP SET-CURRENT DISCARD ; "
    ": COMPARE ( c-addr1 u1 c-addr2 u2 -- comp ) "
    "  BEGIN "
    "    2 PICK 0<> IF "
    "      DUP 0<> IF "
    "        3 PICK C@ 2 PICK C@ 2DUP < IF "
    "          2DROP 2DROP 2DROP -1 TRUE "
    "        ELSE > IF "
    "          2DROP 2DROP 1 TRUE "
    "        ELSE "
    "          3 ROLL CHAR+ 3 ROLL 1- 3 ROLL CHAR+ 3 ROLL 1- FALSE "
    "        THEN THEN "
    "      ELSE "
    "        2DROP 2DROP 1 TRUE "
    "      THEN "
    "    ELSE "
    "      0<> IF "
    "        2DROP DROP -1 TRUE "
    "      ELSE "
    "        2DROP DROP 0 TRUE "
    "      THEN "
    "    THEN "
    "  UNTIL ; "
    ": TO-UPPER ( c -- c ) "
    "  DUP [CHAR] a >= OVER [CHAR] z <= AND IF "
    "    [CHAR] a - [CHAR] A + "
    "  THEN ; "
    ": COMPARE-CASE ( c-addr1 u1 c-addr2 u2 -- comp ) "
    "  BEGIN "
    "    2 PICK 0<> IF "
    "      DUP 0<> IF "
    "        3 PICK C@ TO-UPPER 2 PICK C@ TO-UPPER 2DUP < IF "
    "          2DROP 2DROP 2DROP -1 TRUE "
    "        ELSE > IF "
    "          2DROP 2DROP 1 TRUE "
    "        ELSE "
    "          3 ROLL CHAR+ 3 ROLL 1- 3 ROLL CHAR+ 3 ROLL 1- FALSE "
    "        THEN THEN "
    "      ELSE "
    "        2DROP 2DROP 1 TRUE "
    "      THEN "
    "    ELSE "
    "      0<> IF "
    "        2DROP DROP -1 TRUE "
    "      ELSE "
    "        2DROP DROP 0 TRUE "
    "      THEN "
    "    THEN "
    "  UNTIL ; "
    ": SEARCH-WORDLIST ( c-addr u wid -- xt ) "
    "  FIRST-WORD BEGIN "
    "    DUP 0<> IF "
    "      DUP NAME>STRING DUP 4 PICK = IF "
    "        4 PICK 4 PICK COMPARE-CASE 0= IF "
    "          DUP IS-HIDDEN 0= IF "
    "            ROT ROT 2DROP TRUE "
    "          ELSE "
    "            NAME>NEXT FALSE "
    "          THEN "
    "        ELSE "
    "          NAME>NEXT FALSE "
    "        THEN "
    "      ELSE "
    "        2DROP NAME>NEXT FALSE "
    "      THEN "
    "    ELSE "
    "      ROT ROT 2DROP TRUE "
    "    THEN "
    "  UNTIL ; "
    ": FIND-WORD ( c-addr u -- xt ) "
    "  2>R GET-ORDER 2R> ROT BEGIN "
    "    DUP 0> IF "
    "      1- 2 PICK 2 PICK 5 ROLL SEARCH-WORDLIST DUP 0<> IF "
    "        >R 2 + DROPS R> DUP IS-IMMEDIATE IF 1 ELSE -1 THEN TRUE "
    "      ELSE "
    "        DROP FALSE "
    "      THEN "
    "    ELSE "
    "      DROP 0 TRUE "
    "    THEN "
    "  UNTIL ; "
    ": NEXT-CHAR ( c-addr u -- c-addr u ) 1- SWAP CHAR+ SWAP ; "
    ": NEXT-GET-CHAR ( c-addr u -- c-addr u c ) "
    "  1- SWAP DUP C@ SWAP CHAR+ ROT ROT ; "
    ": PARSE-BASE ( c-addr u -- c-addr u base ) "
    "  DUP 0> IF "
    "    OVER C@ CASE "
    "      [CHAR] % OF NEXT-CHAR 2 ENDOF "
    "      [CHAR] / OF NEXT-CHAR 8 ENDOF "
    "      [CHAR] # OF NEXT-CHAR 10 ENDOF "
    "      [CHAR] $ OF NEXT-CHAR 16 ENDOF "
    "      BASE @ SWAP "
    "    ENDCASE "
    "  ELSE "
    "    BASE @ "
    "  THEN ; "
    ": PARSE-NEGATIVE ( c-addr u -- c-addr u flag ) "
    "  DUP 0> IF "
    "    OVER C@ [CHAR] - = IF NEXT-CHAR TRUE ELSE FALSE THEN "
    "  ELSE "
    "    FALSE "
    "  THEN ; "
    ": PARSE-DIGIT ( c base -- value match valid ) "
    "  SWAP DUP [CHAR] 0 >= OVER [CHAR] 9 <= AND IF "
    "    [CHAR] 0 - DUP ROT < IF TRUE TRUE ELSE DROP 0 FALSE FALSE THEN "
    "  ELSE  "
    "    2DROP 0 FALSE TRUE "
    "  THEN ; "
    ": PARSE-LOWERCASE ( c base -- value match valid ) "
    "  SWAP DUP [CHAR] a >= OVER [CHAR] z <= AND IF "
    "    [CHAR] a - 10 + DUP ROT < IF TRUE TRUE ELSE DROP 0 FALSE FALSE THEN "
    "  ELSE  "
    "    2DROP 0 FALSE TRUE "
    "  THEN ; "
    ": PARSE-UPPERCASE ( c base -- value match valid ) "
    "  SWAP DUP [CHAR] A >= OVER [CHAR] Z <= AND IF "
    "    [CHAR] A - 10 + DUP ROT < IF TRUE TRUE ELSE DROP 0 FALSE FALSE THEN "
    "  ELSE  "
    "    2DROP 0 FALSE TRUE "
    "  THEN ; "
    ": PARSE-NUMBER ( c-addr u -- n flag ) "
    "  PARSE-BASE DUP 2 >= OVER 36 <= AND 2 PICK 0> AND IF "
    "    ROT ROT PARSE-NEGATIVE ROT ROT DUP 0> IF "
    "      0 BEGIN "
    "        OVER 0> IF "
    "          4 PICK * ROT ROT NEXT-GET-CHAR DUP 6 PICK PARSE-DIGIT IF "
    "            IF "
    "              NIP 3 ROLL + FALSE "
    "            ELSE "
    "              DROP DUP 6 PICK PARSE-LOWERCASE IF "
    "                IF "
    "                  NIP 3 ROLL + FALSE "
    "                ELSE "
    "                  DROP 5 PICK PARSE-UPPERCASE IF "
    "                    IF "
    "                      3 ROLL + FALSE "
    "                    ELSE "
    "                      6 DROPS 0 FALSE TRUE "
    "                    THEN "
    "                  ELSE "
    "                    7 DROPS 0 FALSE TRUE "
    "                  THEN "
    "                THEN "
    "              ELSE "
    "                8 DROPS 0 FALSE TRUE "
    "              THEN "
    "            THEN "
    "          ELSE "
    "            8 DROPS 0 FALSE TRUE "
    "          THEN "
    "        ELSE "
    "          4 ROLL DROP 3 ROLL IF NEGATE THEN ROT ROT 2DROP TRUE TRUE "
    "        THEN "
    "      UNTIL "
    "    ELSE "
    "      4 DROPS 0 FALSE "
    "    THEN "
    "  ELSE "
    "    3 DROPS 0 FALSE "
    "  THEN ; "
    "0 HERE ! HERE 1 CELLS TASK-LOCAL CONSTANT (FORMAT-BUFFER) "
    "128 CONSTANT FORMAT-BUFFER-SIZE "
    ": FORMAT-BUFFER (FORMAT-BUFFER) THIS-TASK T@ DUP 0= IF "
    "    DROP FORMAT-BUFFER-SIZE ALLOCATE! "
    "    DUP (FORMAT-BUFFER) THIS-TASK T! "
    "  THEN ; "
    ": COMPLETE-FORMAT-BUFFER ( c-addr -- c-addr u ) "
    "  FORMAT-BUFFER FORMAT-BUFFER-SIZE + OVER - ; "
    ": ADD-CHAR ( c c-addr -- c-addr ) 1 CHARS - TUCK C! ; "
    ": (FORMAT-DECIMAL) ( n -- c-addr ) "
    "  FORMAT-BUFFER FORMAT-BUFFER-SIZE + BEGIN OVER 0 U> WHILE "
    "    OVER 10 UMOD [CHAR] 0 + SWAP ADD-CHAR SWAP 10 U/ SWAP "
    "  REPEAT "
    "  NIP ; "
    ": FORMAT-DECIMAL ( n -- c-addr u ) "
    "  DUP 0< IF "
    "    NEGATE (FORMAT-DECIMAL) [CHAR] - SWAP ADD-CHAR COMPLETE-FORMAT-BUFFER "
    "  ELSE "
    "    (FORMAT-DECIMAL) COMPLETE-FORMAT-BUFFER "
    "  THEN ; "
    ": FORMAT-UNSIGNED ( n -- c-addr u ) "
    "  FORMAT-BUFFER FORMAT-BUFFER-SIZE + BEGIN OVER 0 U> WHILE "
    "    OVER BASE @ UMOD DUP 10 U< IF [CHAR] 0 + ELSE [CHAR] A + 10 - THEN "
    "    SWAP ADD-CHAR SWAP BASE @ U/ SWAP "
    "  REPEAT "
    "  NIP COMPLETE-FORMAT-BUFFER ; "
    ": (FORMAT-2DECIMAL) ( d -- c-addr ) "
    "  FORMAT-BUFFER FORMAT-BUFFER-SIZE + BEGIN 2 PICK 2 PICK 0. DU> WHILE "
    "    2 PICK 2 PICK 10. DUMOD DROP [CHAR] 0 + SWAP ADD-CHAR "
    "    ROT ROT 10. DU/ ROT "
    "  REPEAT "
    "  ROT ROT 2DROP ; "
    ": FORMAT-2DECIMAL ( d -- c-addr u ) "
    "  2DUP D0< IF "
    "    DNEGATE (FORMAT-2DECIMAL) "
    "    [CHAR] - SWAP ADD-CHAR COMPLETE-FORMAT-BUFFER "
    "  ELSE "
    "    (FORMAT-2DECIMAL) COMPLETE-FORMAT-BUFFER "
    "  THEN ; "
    ": FORMAT-2UNSIGNED ( d -- c-addr u ) "
    "  FORMAT-BUFFER FORMAT-BUFFER-SIZE + BASE @ S>D BEGIN "
    "  4 PICK 4 PICK 0. DU> WHILE "
    "    4 PICK 4 PICK 3 PICK 3 PICK DUMOD DROP "
    "    DUP 10 U< IF [CHAR] 0 + ELSE [CHAR] A + 10 - THEN "
    "    3 ROLL ADD-CHAR 4 ROLL 4 ROLL 4 PICK 4 PICK DU/ "
    "    ROT 4 ROLL 4 ROLL "
    "  REPEAT "
    "  2DROP ROT ROT 2DROP COMPLETE-FORMAT-BUFFER ; "
    ": FORMAT-NUMBER ( n -- c-addr u ) "
    "  DUP 0= IF "
    "    DROP [CHAR] 0 FORMAT-BUFFER C! FORMAT-BUFFER 1 CHARS "
    "  ELSE BASE @ 10 = IF "
    "    FORMAT-DECIMAL "
    "  ELSE BASE @ DUP 2 >= SWAP 36 <= AND IF "
    "    FORMAT-UNSIGNED "
    "  ELSE "
    "    DROP FORMAT-BUFFER 0 CHARS "
    "  THEN THEN THEN ; "
    ": FORMAT-2NUMBER ( d -- c-addr u ) "
    "  2DUP D0= IF "
    "    2DROP [CHAR] 0 FORMAT-BUFFER C! FORMAT-BUFFER 1 CHARS "
    "  ELSE BASE @ 10 = IF "
    "    FORMAT-2DECIMAL "
    "  ELSE BASE @ DUP 2 >= SWAP 36 <= AND IF "
    "    FORMAT-2UNSIGNED "
    "  ELSE "
    "    2DROP FORMAT-BUFFER 0 CHARS "
    "  THEN THEN THEN ; "
    ": FORMAT-UNSIGNED-NUMBER ( n -- c-addr u ) "
    "  DUP 0= IF "
    "    DROP [CHAR] 0 FORMAT-BUFFER C! FORMAT-BUFFER 1 CHARS "
    "  ELSE BASE @ DUP 2 >= SWAP 36 <= AND IF "
    "    FORMAT-UNSIGNED "
    "  ELSE "
    "    DROP FORMAT-BUFFER 0 CHARS "
    "  THEN THEN ; "
    ": FORMAT-UNSIGNED-2NUMBER ( d -- c-addr u ) "
    "  2DUP D0= IF "
    "    2DROP [CHAR] 0 FORMAT-BUFFER C! FORMAT-BUFFER 1 CHARS "
    "  ELSE BASE @ DUP 2 >= SWAP 36 <= AND IF "
    "    FORMAT-2UNSIGNED "
    "  ELSE "
    "    2DROP FORMAT-BUFFER 0 CHARS "
    "  THEN THEN ; "
    "6 HERE ! HERE 1 CELLS TASK-LOCAL CONSTANT (PRECISION) "
    ": PRECISION (PRECISION) THIS-TASK T@ ; "
    ": SET-PRECISION (PRECISION) THIS-TASK T! ; "
    ": (.) FORMAT-NUMBER TYPE ; "
    ": (U.) FORMAT-UNSIGNED-NUMBER TYPE ; "
    ": (D.) FORMAT-2NUMBER TYPE ; "
    ": (DU.) FORMAT-UNSIGNED-2NUMBER TYPE ; "
    ": (F.) PRECISION FORMAT-FLOAT TYPE ; "
    ": (FS.) PRECISION FORMAT-FLOAT-SCI TYPE ; "
    ": (BASE.) ['] (.) SWAP BASE-EXECUTE ; "
    ": . (.) SPACE ; "
    ": U. (U.) SPACE ; "
    ": D. (D.) SPACE ; "
    ": DU. (DU.) SPACE ; "
    ": F. (F.) SPACE ; "
    ": FS. (FS.) SPACE ; "
    ": BASE. (BASE.) SPACE ; "
    ": .S DEPTH [CHAR] < EMIT (.) [CHAR] > EMIT SPACE [CHAR] [ EMIT SPACE "
    "  DEPTH DUP 0>= IF "
    "    DUP 0 ?DO DUP ROLL DUP . SWAP LOOP "
    "  THEN DROP [CHAR] ] EMIT SPACE ; "
    ": DETECT-2NUMBER ( c-addr u -- flag ) "
    "  DUP 0> IF 1- + C@ [CHAR] . = ELSE 2DROP FALSE THEN ; "
    ": PARSE-2NUMBER ( c-addr u -- d flag ) "
    "  PARSE-BASE DUP 2 >= OVER 36 <= AND 3 PICK 3 PICK DETECT-2NUMBER AND IF "
    "    ROT ROT 1- PARSE-NEGATIVE ROT ROT DUP 0> IF "
    "      0. BEGIN ( b n a u x1 x2 ) "
    "        2 PICK 0> IF "
    "          5 PICK S>D D* 3 ROLL 3 ROLL NEXT-GET-CHAR ( b n x1 x2 a u c )"
    "          DUP 7 PICK PARSE-DIGIT IF "
    "            IF "
    "              NIP S>D 5 ROLL 5 ROLL D+ ( b n a u x1 x2 ) FALSE "
    "            ELSE "
    "              DROP DUP 7 PICK PARSE-LOWERCASE IF "
    "                IF "
    "                  NIP S>D 5 ROLL 5 ROLL D+ FALSE "
    "                ELSE "
    "                  DROP 6 PICK PARSE-UPPERCASE IF "
    "                    IF "
    "                      S>D 5 ROLL 5 ROLL D+ FALSE "
    "                    ELSE "
    "                      ( b n x1 x2 a u d ) 7 DROPS 0. FALSE TRUE "
    "                    THEN "
    "                  ELSE "
    "                    ( b n x1 x2 a u d f ) 8 DROPS 0. FALSE TRUE "
    "                  THEN "
    "                THEN "
    "              ELSE "
    "                ( b n x1 x2 a u c d f ) 9 DROPS 0. FALSE TRUE "
    "              THEN "
    "            THEN "
    "          ELSE "
    "            ( b n x1 x2 a u c d f ) 9 DROPS 0. FALSE TRUE "
    "          THEN "
    "        ELSE "
    "          ( b n a u x1 x2 ) 5 ROLL DROP 4 ROLL IF DNEGATE THEN "
    "          3 ROLL 3 ROLL 2DROP TRUE TRUE "
    "        THEN "
    "      UNTIL "
    "    ELSE "
    "      4 DROPS 0. FALSE "
    "    THEN "
    "  ELSE "
    "    3 DROPS 0. FALSE "
    "  THEN ; "
    ": F.S FDEPTH [CHAR] < EMIT (.) [CHAR] > EMIT SPACE [CHAR] [ EMIT SPACE "
    "  FDEPTH DUP 0>= IF "
    "    DUP 0 ?DO DUP 1- FROLL FDUP F. LOOP "
    "  THEN DROP [CHAR] ] EMIT SPACE ; "
    ": FIND DUP COUNT FIND-WORD DUP 0 = IF "
    "    DROP 2DROP 0 "
    "  ELSE "
    "    ROT DROP "
    "  THEN ; "
    ": ALSO ( -- ) GET-ORDER OVER SWAP 1+ SET-ORDER ; "
    ": (WORDLIST) ( wid \"<name>\" -- ) "
    "  CREATE , DOES> @ >R GET-ORDER NIP R> SWAP SET-ORDER ; "
    "FORTH-WORDLIST (WORDLIST) FORTH "
    "IO-WORDLIST (WORDLIST) IO "
    "TASK-WORDLIST (WORDLIST) TASK "
    ": ONLY ( -- ) -1 SET-ORDER ; "
    ": PREVIOUS ( -- ) GET-ORDER NIP 1- SET-ORDER ; "
    ": ORDER ( -- ) GET-ORDER 0 ?DO 16 BASE. SPACE LOOP ; "
    "IO-WORDLIST SET-CURRENT "
    ": CLEANUP-INPUTS "
    "  BEGIN "
    "    DUP 0<> IF DUP INPUT-NEXT-INPUT @ 0<> ELSE FALSE THEN "
    "  WHILE "
    "    DUP INPUT-NEXT-INPUT @ SWAP DUP INPUT-CLEANUP @ ?EXECUTE1 "
    "  REPEAT ; "
    ": CLEANUP-INPUT DUP INPUT> CLEANUP-INPUTS SWAP >INPUT ; "
    ": CLEANUP-OUTPUTS "
    "  BEGIN "
    "    DUP 0<> IF DUP OUTPUT-NEXT-OUTPUT @ 0<> ELSE FALSE THEN "
    "  WHILE "
    "    DUP OUTPUT-NEXT-OUTPUT @ SWAP DUP OUTPUT-CLEANUP @ ?EXECUTE1 "
    "  REPEAT ; "
    ": CLEANUP-OUTPUT DUP OUTPUT> CLEANUP-OUTPUTS SWAP >OUTPUT ; "
    ": CLEANUP-ERROR DUP ERROR> CLEANUP-OUTPUTS SWAP >ERROR ; "
    ": CLEANUP DUP CLEANUP-INPUT DUP CLEANUP-OUTPUT CLEANUP-ERROR ; "
    ": CLEANUP-FULL "
    "  DUP CLEANUP "
    "  DUP INPUT> DUP 0<> IF DUP INPUT-CLEANUP @ ?EXECUTE1 ELSE DROP THEN "
    "  DUP OUTPUT> DUP 0<> IF DUP OUTPUT-CLEANUP @ ?EXECUTE1 ELSE DROP THEN "
    "  DUP ERROR> DUP 0<> IF DUP OUTPUT-CLEANUP @ ?EXECUTE1 ELSE DROP THEN "
    "  0 OVER >INPUT 0 OVER >OUTPUT 0 SWAP >ERROR ; "
    "TASK-WORDLIST SET-CURRENT "
    "0 HERE ! HERE 1 CELLS TASK-LOCAL CONSTANT ATEXIT-BUFFER "
    "0 HERE ! HERE 1 CELLS TASK-LOCAL CONSTANT ATEXIT-BUFFER-SIZE "
    "0 HERE ! HERE 1 CELLS TASK-LOCAL CONSTANT ATEXIT-BUFFER-COUNT "
    "0 HERE ! HERE 1 CELLS TASK-LOCAL CONSTANT ATEXIT-BUFFER-LOCK "
    "8 CONSTANT ATEXIT-BUFFER-DEFAULT-SIZE "
    ": ATEXIT ( xt task -- ) "
    "  ATEXIT-BUFFER-LOCK OVER T@ SIMPLE-LOCK "
    "  ATEXIT-BUFFER OVER T@ DUP 0= IF "
    "    DROP ATEXIT-BUFFER-DEFAULT-SIZE ALLOCATE! "
    "    DUP ATEXIT-BUFFER 3 PICK T! "
    "    ATEXIT-BUFFER-DEFAULT-SIZE ATEXIT-BUFFER-SIZE 3 PICK T! "
    "    0 ATEXIT-BUFFER-COUNT 3 PICK T! "
    "  THEN "
    "  ATEXIT-BUFFER-COUNT 2 PICK T@ "
    "  ATEXIT-BUFFER-SIZE 3 PICK T@ >= IF "
    "    ATEXIT-BUFFER-SIZE 2 PICK T@ 2 * "
    "    DUP ATEXIT-BUFFER-SIZE 4 PICK T! RESIZE "
    "  THEN "
    "  ROT SWAP ATEXIT-BUFFER-COUNT 3 PICK T@ CELLS + ! "
    "  ATEXIT-BUFFER-COUNT OVER T@ 1+ ATEXIT-BUFFER-COUNT 2 PICK T! "
    "  ATEXIT-BUFFER-LOCK SWAP T@ SIMPLE-UNLOCK ; "
    ": INIT-ATEXIT ( -- ) "
    "  1 CELLS ALLOCATE! DUP ATEXIT-BUFFER-LOCK THIS-TASK T! 0 SWAP ! ; "
    "INIT-ATEXIT "
    ": EXECUTE-ATEXIT ( -- ) "
    "  ATEXIT-BUFFER-LOCK THIS-TASK T@ SIMPLE-LOCK "
    "  ATEXIT-BUFFER THIS-TASK T@ 0<> IF "
    "    ATEXIT-BUFFER-COUNT THIS-TASK T@ "
    "    BEGIN DUP 0> WHILE "
    "      1- DUP CELLS ATEXIT-BUFFER THIS-TASK T@ + @ "
    "      ATEXIT-BUFFER-LOCK THIS-TASK T@ SIMPLE-UNLOCK "
    "      EXECUTE "
    "      ATEXIT-BUFFER-LOCK THIS-TASK T@ SIMPLE-LOCK "
    "    REPEAT "
    "    ATEXIT-BUFFER THIS-TASK T@ FREE! "
    "    0 ATEXIT-BUFFER THIS-TASK T! "
    "    0 ATEXIT-BUFFER-COUNT THIS-TASK T! "
    "    0 ATEXIT-BUFFER-SIZE THIS-TASK T! "
    "  THEN "
    "  ATEXIT-BUFFER-LOCK THIS-TASK T@ SIMPLE-UNLOCK ; "
    ": DESTROY-ATEXIT ( -- ) ATEXIT-BUFFER-LOCK THIS-TASK T@ FREE! ; "
    ": SPAWN-SIMPLE-EXECUTE "
    "    INIT-ATEXIT EXECUTE EXECUTE-ATEXIT THIS-TASK CLEANUP-FULL "
    "    EXECUTE-ATEXIT DESTROY-ATEXIT THIS-TASK KILL ; "
    ": SPAWN-SIMPLE-NO-IO-EXECUTE "
    "    INIT-ATEXIT EXECUTE EXECUTE-ATEXIT DESTROY-ATEXIT THIS-TASK KILL ; "
    ": SPAWN-SIMPLE ( ... count xt -- task ) "
    "  SPAWN ROT 1+ DUP 0 ?DO "
    "    DUP 1+ ROLL 2 PICK >DATA "
    "  LOOP "
    "  DROP ['] SPAWN-SIMPLE-EXECUTE OVER >INIT-WORD DUP START ; "
    ": SPAWN-SIMPLE-FREE-DATA-ON-EXIT ( ... count xt -- task ) "
    "  SPAWN TRUE OVER >FREE-DATA-ON-EXIT ROT 1+ DUP 0 ?DO "
    "    DUP 1+ ROLL 2 PICK >DATA "
    "  LOOP "
    "  DROP ['] SPAWN-SIMPLE-EXECUTE OVER >INIT-WORD DUP START ; "
    ": SPAWN-SIMPLE-NO-IO ( ... count xt -- task ) "
    "  OLD-SPAWN ROT 1+ DUP 0 ?DO "
    "    DUP 1+ ROLL 2 PICK >DATA "
    "  LOOP "
    "  DROP ['] SPAWN-SIMPLE-NO-IO-EXECUTE OVER >INIT-WORD DUP START ; "
    ": SPAWN-SIMPLE-NO-IO-FREE-DATA-ON-EXIT ( ... count xt -- task ) "
    "  OLD-SPAWN TRUE OVER >FREE-DATA-ON-EXIT ROT 1+ DUP 0 ?DO "
    "    DUP 1+ ROLL 2 PICK >DATA "
    "  LOOP "
    "  DROP ['] SPAWN-SIMPLE-NO-IO-EXECUTE OVER >INIT-WORD DUP START ; "
    ": SPAWN-SIMPLE-NO-DATA ( ... count xt -- task ) "
    "  SPAWN-NO-DATA TUCK >INIT-WORD SWAP ROT 1+ DUP 0 ?DO "
    "    DUP 1+ ROLL 2 PICK >DATA "
    "  LOOP "
    "  DROP ['] SPAWN-SIMPLE-NO-IO-EXECUTE OVER >INIT-WORD DUP START ; "
    "FORTH-WORDLIST SET-CURRENT "
    ": BUFFER: CREATE ALLOT ; "
    ": PARSE SOURCE DROP >IN @ + SWAP COUNT-CHARS-UNTIL ; "
    ": S\" SKIP-WHITESPACE [CHAR] \" PARSE DUP ALLOCATE! 2DUP & "
    "  (LITERAL) , & (LITERAL) , SWAP MOVE ; IMMEDIATE "
    ": C\" SKIP-WHITESPACE [CHAR] \" PARSE DUP 255 > IF DROP 255 THEN DUP 1+ "
    "  ALLOCATE! DUP & (LITERAL) , 2DUP C@ 1+ SWAP MOVE ; IMMEDIATE "
    ": ERASE BEGIN DUP 0 > WHILE 1 - SWAP 0 OVER C! 1 + SWAP REPEAT 2DROP ; "
    ": ** DUP 0> IF "
    "    1 BEGIN "
    "      OVER 1 AND IF "
    "        2 PICK * "
    "      THEN "
    "      SWAP 1 RSHIFT DUP 0= IF "
    "        DROP NIP TRUE "
    "      ELSE "
    "        ROT DUP * SWAP ROT FALSE "
    "      THEN "
    "    UNTIL "
    "  ELSE 0= IF "
    "    DROP 1 "
    "  ELSE "
    "    DROP 0 "
    "  THEN THEN ; "  
    ": D** ( d n -- d ) "
    "  DUP 0> IF "
    "    1. BEGIN "
    "      2 PICK 1 AND IF "
    "        4 PICK 4 PICK D* "
    "      THEN "
    "      ROT 1 RSHIFT DUP 0= IF "
    "        DROP 3 ROLL 3 ROLL 2DROP TRUE "
    "      ELSE "
    "        4 ROLL 4 ROLL 2DUP D* ROT 4 ROLL 4 ROLL FALSE "
    "      THEN "
    "    UNTIL "
    "  ELSE 0= IF "
    "    2DROP 1. "
    "  ELSE "
    "    2DROP 0. "
    "  THEN THEN ; "
    ": ABS DUP 0< IF NEGATE THEN ; "
    ": MIN 2DUP > IF SWAP THEN DROP ; "
    ": MAX 2DUP < IF SWAP THEN DROP ; "
    ": 4DUP 3 PICK 3 PICK 3 PICK 3 PICK ; "
    ": DABS 2DUP D0< IF DNEGATE THEN ; "
    ": DMIN 4DUP D> IF 2SWAP THEN 2DROP ; "
    ": DMAX 4DUP D< IF 2SWAP THEN 2DROP ; "
    ": FABS FDUP F0< IF FNEGATE THEN ; "
    ": FMIN F2DUP F> IF FSWAP THEN FDROP ; "
    ": FMAX F2DUP F< IF FSWAP THEN FDROP ; "
    ": SPACES 0 MAX 0 ?DO SPACE LOOP ; "
    ": .\" SKIP-WHITESPACE [CHAR] \" PARSE DUP ALLOCATE! 2DUP & "
    "  (LITERAL) , & (LITERAL) , SWAP MOVE & TYPE ; IMMEDIATE "
    ": .( SKIP-WHITESPACE [CHAR] ) PARSE TYPE ; IMMEDIATE "
    ": ERROR\" SKIP-WHITESPACE [CHAR] \" PARSE DUP ALLOCATE! 2DUP & "
    "  (LITERAL) , & (LITERAL) , SWAP MOVE & "
    "  ERROR-TYPE ; IMMEDIATE "
    "IO-WORDLIST SET-CURRENT "
    ": DROP-INPUT DUP INPUT> DUP 0<> IF "
    "    DUP INPUT-NEXT-INPUT @ 0<> IF INPUT-NEXT-INPUT @ THEN "
    "  THEN "
    "  SWAP >INPUT ; "
    ": DROP-OUTPUT DUP OUTPUT> DUP 0<> IF "
    "    DUP OUTPUT-NEXT-OUTPUT @ 0<> IF OUTPUT-NEXT-OUTPUT @ THEN "
    "  THEN "
    "  SWAP >OUTPUT ; "
    ": DROP-ERROR DUP ERROR> DUP 0<> IF "
    "    DUP OUTPUT-NEXT-OUTPUT @ 0<> IF OUTPUT-NEXT-OUTPUT @ THEN "
    "  THEN "
    "  SWAP >ERROR ; "
    ": STRING>SOURCE-CLEANUP ( source -- ) "
    "  DUP INPUT-BUFFER @ FREE! FREE! ; "
    ": COPY-BUFFER ( addr count -- addr count ) "
    "  DUP ALLOCATE! DUP 3 ROLL SWAP 3 PICK MOVE SWAP ; "
    ": SET-INPUT-BUFFER ( addr count input -- ) "
    "  TUCK INPUT-COUNT ! INPUT-BUFFER ! ; "
    ": SET-STRING-INPUT-DEFAULTS ( input -- ) "
    "  0 OVER INPUT-INDEX ! TRUE OVER INPUT-IS-CLOSED ! "
    "  ['] STRING>SOURCE-CLEANUP OVER INPUT-CLEANUP ! 0 OVER "
    "  INPUT-REFILL ! 0 OVER INPUT-ARG ! -1 OVER INPUT-SOURCE-ID ! "
    "  0 SWAP INPUT-NEXT-INPUT ! ; "
    ": STRING>SOURCE ( addr count -- input ) "
    "  COPY-BUFFER INPUT-SIZE ALLOCATE! DUP 3 ROLL 3 ROLL 3 ROLL "
    "  SET-INPUT-BUFFER DUP SET-STRING-INPUT-DEFAULTS ; "
    ": PUSH-INPUT ( input -- ) "
    "  THIS-TASK INPUT> OVER INPUT-NEXT-INPUT ! THIS-TASK >INPUT ; "
    "FORTH-WORDLIST SET-CURRENT "
    ": EVALUATE ( addr count -- ? ) "
    "  STRING>SOURCE PUSH-INPUT INTERPRET THIS-TASK DROP-INPUT ; "
    ": BACKSPACE 8 ; "
    ": ABORT\" & IF SKIP-WHITESPACE [CHAR] \" PARSE DUP ALLOCATE! "
    "  2DUP & SPACE & (LITERAL) , & (LITERAL) , SWAP MOVE & TYPE "
    "  & (LITERAL) EABORT\" , & THROW & THEN ; IMMEDIATE "
    "IO-WORDLIST SET-CURRENT "
    "BEGIN-STRUCTURE FILE-SIZE "
    "  FIELD: FILE-FD "
    "  FIELD: FILE-BUFFER-SIZE "
    "  FIELD: FILE-DATA-SIZE "
    "  FIELD: FILE-BUFFER "
    "  FIELD: FILE-IS-CLOSED "
    "  FIELD: FILE-IS-READ-ONLY "
    "END-STRUCTURE "
    "256 CONSTANT DEFAULT-FILE-BUFFER-SIZE "
    "0 CONSTANT NO-ERROR "
    "-1 CONSTANT GENERIC-ERROR "
    ": INIT-FILE ( fd read-only -- fileid ) "
    "  FILE-SIZE ALLOCATE! DEFAULT-FILE-BUFFER-SIZE ALLOCATE! "
    "  OVER FILE-BUFFER ! DEFAULT-FILE-BUFFER-SIZE OVER FILE-BUFFER-SIZE ! "
    "  0 OVER FILE-DATA-SIZE ! FALSE OVER FILE-IS-CLOSED ! ROT OVER "
    "  FILE-FD ! TUCK FILE-IS-READ-ONLY ! ; "
    "FORTH-WORDLIST SET-CURRENT "
    ": BIN ( fam1 -- fam2 ) ; "
    ": FLUSH-FILE ( fileid -- ior ) "
    "  DUP FILE-IS-CLOSED @ INVERT IF "
    "    DUP FILE-IS-READ-ONLY @ INVERT IF "
    "      DUP FILE-BUFFER @ OVER FILE-DATA-SIZE @ DUP 0<> IF "
    "        2 PICK FILE-FD @ "
    "        IO-WRITE-ASYNC IO-ACTION-DESTROY "
    "        0 SWAP FILE-DATA-SIZE ! NO-ERROR "
    "      ELSE "
    "        2DROP DROP NO-ERROR "
    "      THEN "
    "    ELSE "
    "      DROP NO-ERROR "
    "    THEN "
    "  ELSE "
    "    DROP GENERIC-ERROR "
    "  THEN ; "
    ": CLOSE-FILE ( fileid -- ) "
    "  DUP FILE-IS-CLOSED @ INVERT IF "
    "    DUP FLUSH-FILE DROP TRUE OVER FILE-IS-CLOSED ! "
    "    DUP FILE-FD @ IO-CLOSE-ASYNC IO-ACTION-DESTROY "
    "    DUP FILE-BUFFER @ FREE! FREE! "
    "  ELSE "
    "    DROP "
    "  THEN ; "
    ": OPEN-FILE ( c-addr u fam -- fileid ior ) "
    "  DUP 3 ROLL 3 ROLL 3 ROLL "
    "  IO-IRUSR IO-IWUSR OR IO-IRGRP OR IO-IWGRP OR IO-IROTH OR IO-IWOTH OR "
    "  IO-OPEN DUP IF "
    "    NIP NIP 0 SWAP "
    "  ELSE "
    "    DROP SWAP DUP IO-WRONLY AND 0= SWAP IO-RDWR AND 0= AND "
    "    INIT-FILE NO-ERROR "
    "  THEN ; "
    ": CREATE-FILE ( c-addr u fam -- fileid ior ) "
    "  IO-CREAT OR IO-TRUNC OR OPEN-FILE ; "
    ": DELETE-FILE ( c-addr u -- ior ) IO-DELETE ; "
    ": FILE-POSITION ( fileid -- ud ior ) "
    "  DUP FILE-IS-CLOSED @ INVERT IF "
    "    DUP FILE-FD @ IO-TELL DUP IO-ACTION-GET-STATE SWAP IO-ACTION-DESTROY "
    "    DUP IO-STATE-HAS-ERROR IF "
    "      IO-STATE-DESTROY DROP 0 0 GENERIC-ERROR "
    "    ELSE "
    "      DUP IO-STATE-GET-OFFSET SWAP IO-STATE-DESTROY "
    "      SWAP FILE-DATA-SIZE @ + 0 NO-ERROR "
    "    THEN "
    "  ELSE "
    "    0 0 GENERIC-ERROR "
    "  THEN ; "
    ": REPOSITION-FILE ( ud fileid -- ior ) "
    "  DUP FLUSH-FILE DUP NO-ERROR = IF "
    "    DROP NIP DUP FILE-IS-CLOSED @ INVERT IF "
    "      FILE-FD @ IO-SEEK-SET SWAP IO-SEEK-ASYNC IO-ACTION-DESTROY NO-ERROR "
    "    ELSE "
    "      GENERIC-ERROR "
    "    THEN "
    "  THEN ; "
    ": RENAME-FILE ( c-addr1 u1 c-addr2 u2 -- ior ) IO-RENAME ; " 
    ": ACTION>ERROR ( action -- flag ) "
    "  DUP IO-ACTION-GET-STATE SWAP IO-ACTION-DESTROY "
    "  DUP IO-STATE-HAS-ERROR SWAP IO-STATE-DESTROY ; "
    ": FILE-SIZE ( fileid -- ud ior )  "
    "  DUP FILE-POSITION NIP DUP INVERT IF "
    "    DROP 0 IO-SEEK-END 3 PICK FILE-FD @ IO-SEEK-BLOCK DUP "
    "    IO-ACTION-GET-STATE SWAP IO-ACTION-DESTROY "
    "    DUP IO-STATE-HAS-ERROR INVERT IF "
    "      DUP IO-STATE-GET-OFFSET SWAP IO-STATE-DESTROY "
    "      SWAP IO-SEEK-SET 3 ROLL FILE-FD @ IO-SEEK-BLOCK ACTION>ERROR "
    "      INVERT IF "
    "        0 NO-ERROR "
    "      ELSE "
    "        2DROP 0 0 GENERIC-ERROR "
    "      THEN "
    "    ELSE "
    "      IO-STATE-DESTROY 2DROP 0 0 GENERIC-ERROR "
    "    THEN "
    "  ELSE "
    "    2DROP 0 0 GENERIC-ERROR "
    "  THEN ; "
    ": FILE-STATUS ( fileid -- flag ) FILE-IS-CLOSED @ ; "
    "IO-RDONLY CONSTANT R/O "
    "IO-WRONLY CONSTANT W/O "
    "IO-RDWR CONSTANT R/W "
    ": READ-FILE ( c-addr u1 fileid -- u2 ior ) "
    "  DUP FLUSH-FILE DUP NO-ERROR = IF "
    "    DROP FILE-FD @ IO-READ-BLOCK DUP IO-ACTION-GET-STATE SWAP "
    "    IO-ACTION-DESTROY DUP IO-STATE-HAS-ERROR IF "
    "      IO-ACTION-DESTROY 0 GENERIC-ERROR "
    "    ELSE "
    "      DUP IO-STATE-GET-INDEX SWAP IO-STATE-DESTROY NO-ERROR "
    "    THEN "
    "  ELSE "
    "    NIP 0 SWAP "
    "  THEN ; "
    ": ADVANCE-BUFFER ( c-addr1 u1 u2 -- c-addr3 u3 ) "
    "  DUP 3 ROLL + ROT ROT - ; "
    ": READ-LINE ( c-addr u1 fileid -- u2 flag ior ) "
    "  0 ROT 0 ?DO "
    "    2 PICK 1 3 PICK READ-FILE DUP NO-ERROR = IF "
    "      DROP 0= IF "
    "        ROT ROT 2DROP NIP DUP 0<> NO-ERROR UNLOOP EXIT "
    "      ELSE "
    "        2 PICK C@ NEWLINE = IF "
    "          ROT ROT 2DROP TRUE NO-ERROR UNLOOP EXIT "
    "        ELSE "
    "          1+ ROT CHAR+ ROT ROT "
    "        THEN "
    "      THEN "
    "    ELSE "
    "      ROT ROT 2DROP ROT ROT 2DROP 0 FALSE ROT "
    "    THEN "
    "  LOOP "
    "  ROT ROT 2DROP TRUE NO-ERROR ; "
    ": FILL-BUFFER ( c-addr u1 fileid -- u2 ) "
    "  DUP FILE-BUFFER-SIZE @ OVER FILE-DATA-SIZE @ - 2 PICK < IF "
    "    DUP FILE-BUFFER-SIZE @ OVER FILE-DATA-SIZE @ - ROT DROP SWAP "
    "  THEN "
    "  ROT OVER FILE-BUFFER @ 2 PICK FILE-DATA-SIZE @ + 3 PICK MOVE "
    "  DUP FILE-DATA-SIZE @ 2 PICK + SWAP FILE-DATA-SIZE ! ; "
    ": WRITE-FILE ( c-addr u fileid -- ior ) "
    "  DUP FILE-IS-READ-ONLY @ 0= IF "
    "    BEGIN "
    "      2 PICK 2 PICK 2 PICK FILL-BUFFER DUP 3 PICK < IF "
    "        OVER FLUSH-FILE DUP NO-ERROR = IF "
    "          3 ROLL 3 ROLL 2 ROLL ADVANCE-BUFFER 2 ROLL FALSE "
    "        ELSE "
    "          2DROP 2DROP DROP GENERIC-ERROR TRUE "
    "        THEN "
    "      ELSE "
    "        2DROP 2DROP NO-ERROR TRUE "
    "      THEN "
    "    UNTIL "
    "  ELSE "
    "    2DROP DROP GENERIC-ERROR "
    "  THEN ; "
    ": WRITE-LINE ( c-addr u fileid -- ior ) "
    "  DUP 3 ROLL 3 ROLL 3 ROLL WRITE-FILE DUP NO-ERROR = IF "
    "    DROP NEWLINE HERE C! HERE 1 ROT WRITE-FILE "
    "  THEN ; "
    "IO-WORDLIST SET-CURRENT "
    "BEGIN-STRUCTURE FILE-SOURCE-INFO-SIZE "
    "  FIELD: FILE-SOURCE-FILE "
    "  FIELD: FILE-SOURCE-BUFFER-SIZE "
    "  FIELD: FILE-SOURCE-DATA-SIZE "
    "END-STRUCTURE "
    "256 CONSTANT DEFAULT-FILE-SOURCE-BUFFER-SIZE "
    ": ADVANCE-FILE ( source -- ) "
    "  DUP INPUT-BUFFER @ OVER INPUT-COUNT @ + OVER INPUT-BUFFER @ "
    "  2 PICK INPUT-ARG @ FILE-SOURCE-DATA-SIZE @ 3 PICK INPUT-COUNT @ - MOVE "
    "  DUP INPUT-ARG @ FILE-SOURCE-DATA-SIZE @ OVER INPUT-COUNT @ - "
    "  OVER INPUT-ARG @ FILE-SOURCE-DATA-SIZE ! "
    "  0 SWAP INPUT-COUNT ! ; "
    ": FIND-FILE-SOURCE-NEWLINE ( source -- ) "
    "  DUP INPUT-IS-CLOSED @ INVERT IF "
    "    BEGIN "
    "      DUP INPUT-COUNT @ OVER INPUT-ARG @ FILE-SOURCE-DATA-SIZE @ < IF "
    "        DUP INPUT-BUFFER @ OVER INPUT-COUNT @ + C@ NEWLINE = IF "
    "          DUP INPUT-COUNT @ 1+ SWAP INPUT-COUNT ! TRUE TRUE "
    "        ELSE "
    "          DUP INPUT-COUNT @ 1+ OVER INPUT-COUNT ! FALSE "
    "        THEN "
    "      ELSE "
    "        DROP FALSE TRUE "
    "      THEN "
    "    UNTIL "
    "  ELSE "
    "    DUP INPUT-ARG @ FILE-SOURCE-DATA-SIZE @ SWAP INPUT-COUNT ! TRUE "
    "  THEN ; "
    ": TRY-EXPAND-FILE-SOURCE-BUFFER ( source -- ) "
    "  DUP INPUT-ARG @ FILE-SOURCE-BUFFER-SIZE @ "
    "  OVER INPUT-ARG @ FILE-SOURCE-DATA-SIZE @ = IF "
    "    DUP INPUT-BUFFER @ OVER INPUT-ARG @ FILE-SOURCE-BUFFER-SIZE @ 2 * RESIZE "
    "    OVER INPUT-BUFFER ! "
    "    DUP INPUT-ARG @ FILE-SOURCE-BUFFER-SIZE @ 2 * "
    "    SWAP INPUT-ARG @ FILE-SOURCE-BUFFER-SIZE ! "
    "  ELSE "
    "    DROP "
    "  THEN ; "
    ": TRY-READ-FILE-SOURCE-LINE ( source -- ) "
    "  DUP TRY-EXPAND-FILE-SOURCE-BUFFER "
    "  DUP INPUT-BUFFER @ OVER INPUT-ARG @ FILE-SOURCE-DATA-SIZE @ + "
    "  OVER INPUT-ARG @ DUP FILE-SOURCE-BUFFER-SIZE @ SWAP FILE-SOURCE-DATA-SIZE @ - "
    "  2 PICK INPUT-ARG @ FILE-SOURCE-FILE @ READ-FILE NO-ERROR <> IF "
    "    DROP TRUE SWAP INPUT-IS-CLOSED ! "
    "  ELSE "
    "    DUP 0= IF "
    "      DROP TRUE SWAP INPUT-IS-CLOSED ! "
    "    ELSE "
    "      OVER INPUT-ARG @ TUCK "
    "      FILE-SOURCE-DATA-SIZE @ + SWAP FILE-SOURCE-DATA-SIZE ! DROP "
    "    THEN "
    "  THEN ; "
    ": REFILL-FILE ( source -- flag ) "
    "  DUP 0<> IF "
    "    DUP INPUT-INDEX @ OVER INPUT-COUNT @ = OVER INPUT-IS-CLOSED @ AND IF "
    "      DROP FALSE "
    "    ELSE "
    "      0 OVER INPUT-INDEX ! "
    "      DUP ADVANCE-FILE BEGIN DUP FIND-FILE-SOURCE-NEWLINE INVERT WHILE "
    "        DUP TRY-READ-FILE-SOURCE-LINE "
    "      REPEAT DROP TRUE "
    "    THEN "
    "  ELSE "
    "    DROP FALSE "
    "  THEN ; "
    ": FILE>SOURCE-CLEANUP ( source -- ) "
    "  DUP INPUT-ARG @ FILE-SOURCE-FILE @ CLOSE-FILE "
    "  DUP INPUT-BUFFER @ FREE! DUP INPUT-ARG @ FREE! FREE! ; "
    ": FILE>SOURCE ( fileid -- input ) "
    "  INPUT-SIZE ALLOCATE! FILE-SOURCE-INFO-SIZE ALLOCATE! "
    "  DEFAULT-FILE-SOURCE-BUFFER-SIZE OVER FILE-SOURCE-BUFFER-SIZE ! "
    "  0 OVER FILE-SOURCE-DATA-SIZE ! "
    "  2 PICK OVER FILE-SOURCE-FILE ! "
    "  2 PICK 2 PICK INPUT-SOURCE-ID ! "
    "  OVER INPUT-ARG ! "
    "  DEFAULT-FILE-SOURCE-BUFFER-SIZE ALLOCATE! OVER INPUT-BUFFER ! "
    "  0 OVER INPUT-INDEX ! 0 OVER INPUT-COUNT ! "
    "  FALSE OVER INPUT-IS-CLOSED ! "
    "  ['] FILE>SOURCE-CLEANUP OVER INPUT-CLEANUP ! "
    "  ['] REFILL-FILE OVER INPUT-REFILL ! "
    "  0 OVER INPUT-NEXT-INPUT ! NIP ; "
    "FORTH-WORDLIST SET-CURRENT "
    ": REFILL ( -- flag ) THIS-TASK INPUT> DUP INPUT-REFILL @ DUP IF "
    "    EXECUTE "
    "  ELSE "
    "    2DROP FALSE "
    "  THEN ; "
    ": SOURCE-ID ( -- id ) THIS-TASK INPUT> INPUT-SOURCE-ID @ ; "
    ": ADVANCE-TO-END SOURCE NIP >IN ! ; "
    "VARIABLE REGISTERED-FILES 0 REGISTERED-FILES ! "
    "NEW-LOCK CONSTANT REGISTERED-FILES-LOCK "
    "BEGIN-STRUCTURE REGISTERED-HEADER-SIZE "
    "  FIELD: REGISTERED-NEXT "
    "  FIELD: REGISTERED-LEN "
    "END-STRUCTURE "
    "REGISTERED-HEADER-SIZE OFFSET REGISTERED-NAME "
    ": FIND-REGISTERED-FILE ( c-addr u -- flag ) "
    "  REGISTERED-FILES @ BEGIN "
    "    DUP 0<> IF "
    "      DUP REGISTERED-NAME OVER REGISTERED-LEN @ "
    "      4 PICK 4 PICK COMPARE 0= IF "
    "        DROP 2DROP TRUE TRUE "
    "      ELSE "
    "        REGISTERED-NEXT @ FALSE "
    "      THEN "
    "    ELSE "
    "      DROP 2DROP FALSE TRUE "
    "    THEN "
    "  UNTIL ; "
    ": REGISTER-FILE ( c-addr u -- flag ) "
    "  REGISTERED-FILES-LOCK LOCK "
    "  2DUP FIND-REGISTERED-FILE INVERT IF "
    "    DUP REGISTERED-HEADER-SIZE + ALLOCATE! "
    "    REGISTERED-FILES @ OVER REGISTERED-NEXT ! DUP REGISTERED-FILES ! "
    "    2DUP REGISTERED-LEN ! REGISTERED-NAME SWAP MOVE FALSE "
    "  ELSE "
    "    2DROP TRUE "
    "  THEN "
    "  REGISTERED-FILES-LOCK UNLOCK ; "
    ": INTERPRET-FILE ( -- ) POSTPONE [ BEGIN REFILL WHILE INTERPRET REPEAT ; "
    ": INCLUDED ( c-addr u -- ? ) "
    "  2DUP REGISTER-FILE DROP R/O OPEN-FILE ABORT\" Unable to open file \" "
    "  FILE>SOURCE PUSH-INPUT INTERPRET-FILE THIS-TASK DROP-INPUT ; "
    ": INCLUDE ( \"filename\" -- ? ) "
    "  PARSE-NAME INCLUDED ; "
    ": REQUIRED ( c-addr u -- ? ) "
    "  2DUP REGISTER-FILE INVERT IF "
    "    R/O OPEN-FILE ABORT\" Unable to open file \" "
    "    FILE>SOURCE PUSH-INPUT INTERPRET-FILE THIS-TASK DROP-INPUT "
    "  ELSE "
    "    2DROP "
    "  THEN ; "
    ": REQUIRE ( \"filename\" -- ? ) "
    "  PARSE-NAME REQUIRED ; "
    "16 CELLS CONSTANT DATA-STACK-TOP-ROOM "
    "16 FLOATS CONSTANT FLOAT-STACK-TOP-ROOM "
    "16 CELLS CONSTANT RETURN-STACK-TOP-ROOM "
    ":NONAME "
    "  BEGIN "
    "    PARSE-NAME DUP 0<> IF "
    "      STATE @ IF "
    "        FIND-WORD DUP 0<> IF "
    "          1 = IF "
    "            EXECUTE "
    "          ELSE "
    "            COMPILE, "
    "          THEN "
    "        ELSE "
    "          DROP 2DUP PARSE-NUMBER 0= IF "
    "            DROP 2DUP PARSE-FLOAT 0= IF "
    "              FDROP 2DUP PARSE-2NUMBER 0= IF "
    "                2DROP ADVANCE-TO-END "
    "                SPACE .\" unable to parse: \" TYPE ERETURN THROW "
    "              ELSE "
    "                ROT DROP ROT DROP SWAP & (LITERAL) , & (LITERAL) , "
    "              THEN  "
    "            ELSE "
    "              2DROP & (FLITERAL) F, "
    "            THEN "
    "          ELSE "
    "            ROT ROT 2DROP & (LITERAL) , "
    "          THEN "
    "        THEN "
    "      ELSE "
    "        FIND-WORD 0<> IF "
    "          EXECUTE "
    "        ELSE "
    "          2DUP PARSE-NUMBER 0= IF "
    "            DROP 2DUP PARSE-FLOAT 0= IF "
    "              FDROP 2DUP PARSE-2NUMBER 0= IF "
    "                2DROP ADVANCE-TO-END "
    "                SPACE .\" unable to parse: \" TYPE ERETURN THROW "
    "              ELSE "
    "                ROT DROP ROT DROP "
    "              THEN "
    "            ELSE "
    "              2DROP "
    "            THEN "
    "          ELSE "
    "            ROT ROT 2DROP "
    "          THEN "
    "        THEN "
    "      THEN "
    "      SP@ SP0 > IF "
    "        ESTACK-UNDERFLOW THROW "
    "      ELSE SP@ SPF DATA-STACK-TOP-ROOM + < IF "
    "        ESTACK-OVERFLOW THROW "
    "      ELSE FP@ FP0 > IF "
    "        EFLOAT-STACK-UNDERFLOW THROW "
    "      ELSE FP@ FPF FLOAT-STACK-TOP-ROOM + < IF "
    "        EFLOAT-STACK-OVERFLOW THROW "
    "      ELSE RP@ RP0 > IF "
    "        ERETURN-STACK-UNDERFLOW THROW "
    "      ELSE RP@ RPF RETURN-STACK-TOP-ROOM + < IF "
    "        ERETURN-STACK-OVERFLOW THROW "
    "      THEN THEN THEN THEN THEN THEN "
    "      FALSE "
    "    ELSE "
    "      2DROP TRUE "
    "    THEN "
    "  UNTIL ; IS INTERPRET "
    ": RESET SP0 SP! FP0 FP! R> RP0 RP! >R POSTPONE [ FALSE GLOBAL-TRACE ;  "
    ": QUIT "
    "  RP0 RP! THIS-TASK CLEANUP POSTPONE [ "
    "  THIS-TASK INPUT> DUP 0<> IF "
    "    INPUT-IS-CLOSED @ INVERT IF REFILL ELSE TRUE THEN IF "
    "      BEGIN "
    "        ['] INTERPRET CATCH CASE "
    "          0 OF STATE @ 0= IF SPACE .\" ok\" THEN CR ENDOF "
    "          ERETURN OF CR POSTPONE [ ENDOF "
    "          EABORT OF RESET SPACE .\" aborted\" CR ENDOF "
    "          EABORT\" OF RESET CR ENDOF "
    "          ESTACK-UNDERFLOW OF RESET SPACE .\" stack underflow\" CR ENDOF "
    "          ESTACK-OVERFLOW OF RESET SPACE .\" stack overflow\" CR ENDOF "
    "          EFLOAT-STACK-UNDERFLOW OF "
    "            RESET SPACE .\" float stack underflow\" CR "
    "          ENDOF "
    "          EFLOAT-STACK-OVERFLOW OF "
    "            RESET SPACE .\" float stack overflow\" CR "
    "          ENDOF "
    "          ERETURN-STACK-UNDERFLOW OF "
    "            RESET SPACE .\" return stack underflow\" CR "
    "          ENDOF "
    "          ERETURN-STACK-UNDERFLOW OF "
    "            RESET SPACE .\" return stack underflow\" CR "
    "          ENDOF "
    "          SPACE .\" exception \" DUP 10 BASE. CR POSTPONE [ "
    "        ENDCASE "
    "        REFILL INVERT "
    "      UNTIL "
    "    THEN "
    "  ELSE "
    "    DROP "
    "  THEN "
    "  THIS-TASK DUP CLEANUP-FULL KILL ; "
    ": HANDLE-ABORT RESET QUIT ; "
    "' HANDLE-ABORT DUP >DEFAULT-ABORT THIS-TASK >ABORT "
    ": INIT-EXTERNAL FORTH-WORDLIST 1 SET-ORDER "
    "  S\" src/forth/init.fs\" INCLUDED ; "
    ": HANDLE-ROOT-EXCEPTION "
    "  ['] INIT-EXTERNAL CATCH .\" exception \" 10 BASE. "
    "  THIS-TASK KILL ; "
    "HANDLE-ROOT-EXCEPTION ";
  if(!(input = af_new_string_input(global, code, (af_cell_t)strlen(code)))) {
    af_handle_out_of_memory(global, task);
    return;
  }
  task->current_input = input;
  af_interpret(global, task);
}
